/**
 * Created by lyle on 14-4-13.
 */



exports.doCompile = function(socket)
{
    var spawn = require("child_process").spawn;
    var codeFile = require("./staticVar.js").getCodeFileName();

    var gcc = spawn('gcc',[codeFile,'-g']);//着一句不能写到外面, 否则编译的是上次的结果
    var str = "";
    var tmp = "";

    console.log('开始编译');

    gcc.stdout.setEncoding('utf8');
    gcc.stderr.setEncoding('utf8');

    /*异步工作虽然好用,但是问题也很多,在这里我想等待标准出错的数据, 可能有两条,然后一起发送到客户端
    * 但是, 不知道怎么等, 因为标准出错的数据是一条一条发出来的*/
    gcc.stderr.on('data',function(data)
    {
        tmp = data.toString('utf8');
        tmp = tmp.slice(tmp.indexOf(":")+1);//+1 不要冒号
        str=str+tmp+"<br />";
    });
    gcc.stderr.on('end',function()
    {
        console.log(str);
        if(str.length>0)
        {
            socket.emit('codeCompileFail',{gccOutPut:str});
            return false;
        }
        else
        {
            console.log('编译完成');
            socket.emit('codeCompileSuccess',{});
        }
    });
    /*很难预测异步事件程序的执行流程, 虽然可以提示代码编译完成, 但是每次退出的时候都会关闭
    stderr流, 因此总会发生end事件,所以最后会发送一条编译失败的消息
    gcc.stdout.on('end',function()
    {
        console.log('编译完成');
        socket.emit('codeCompileSuccess',{});
        return true;
    });
    */
};